package helper

import helper.Crypto._
import java.nio.charset.StandardCharsets
import org.junit.runner.RunWith
import org.scalacheck.{Arbitrary, Gen}
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification
import org.specs2.runner.JUnitRunner
import scala.util.Success

object CryptoTestValues {
  val testKey = Crypto.decodeKeyBase64("zCNLgkZauiZ072v8ocC6pNZpwtwx/L4Sk9eRPQm2WA8=")
  val pt = "plaintext message"
  val ptBytes = pt.getBytes(StandardCharsets.UTF_8)
  val ctNoAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbBV9Y7blaVRQ4TAcmdJe0Og"
  val ctNoAADBytes = Crypto.base64Decoder.decode(ctNoAAD)
  val ctWithAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbAFhFrzlFNz0cmYHt+TLzkK"
  val ctWithAADBytes = Crypto.base64Decoder.decode(ctWithAAD)

  val invalidKey = Crypto.decodeKeyBase64("nhblIEuU2o4mJunzDRBqhrFncBFcpiJP6Jz6n8RxnMg=")
}

object CryptoScalaCheck {

  implicit val keyGen: Gen[Key] = Gen.resultOf((_: Int) => generateRandomKey())
  implicit val keyArb: Arbitrary[Key] = Arbitrary(keyGen)

  case class BlobLessThan10Mb(bytes: Array[Byte])

  implicit val blobLessThan10MbGen: Gen[BlobLessThan10Mb] = for {
    size <- Gen.choose(0, 10 * 1024 * 1024)
    bytes <- Gen.containerOfN[Array, Byte](size, implicitly[Arbitrary[Byte]].arbitrary)
  } yield BlobLessThan10Mb(bytes)

  implicit val blobLessThan10MbArb: Arbitrary[BlobLessThan10Mb] = Arbitrary(blobLessThan10MbGen)

}

@RunWith(classOf[JUnitRunner])
class CryptoHelperSpec extends Specification with ScalaCheck {

  "Given hand-picked data, crypto functions should" >> {
    import CryptoTestValues._

    "decrypt correctly ciphertexts (generated by another impl)" >> {
      Crypto.decryptField(ctNoAAD, "", testKey) must equalTo(Success(pt))
      Crypto.decryptField(ctNoAAD, "something", testKey).isFailure must beTrue

      Crypto.decryptField(ctWithAAD, "some aad", testKey) must equalTo(Success(pt))
      Crypto.decryptField(ctWithAAD, "other aad", testKey).isFailure must beTrue

      Crypto.decryptField(ctNoAAD, "", invalidKey).isFailure must beTrue
      Crypto.decryptField(ctWithAAD, "some aad", invalidKey).isFailure must beTrue
    }
  }

  "Given arbitrary values, crypto functions should" >> {
    import CryptoScalaCheck._

    "encode and decode correctly keys" >> {
      prop { (key: Key) =>
        val encoded = encodeKeyBase64(key)
        val roundtrip = decodeKeyBase64(encoded)
        key === roundtrip
      }
    }

    "encrypt then decrypt in an idempotent way" >> {
      prop { (pt: String, key: Key, aad: String) =>
        val ct = encryptField(pt, aad, key)
        val roundtrip = ct.flatMap(ct => decryptField(ct, aad, key))
        Success(pt) === roundtrip
      }
    }

  }

}
