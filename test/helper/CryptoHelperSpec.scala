package helper

import helper.Crypto._
import java.nio.charset.StandardCharsets
import org.junit.runner.RunWith
import org.scalacheck.{Arbitrary, Gen}
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification
import org.specs2.runner.JUnitRunner
import scala.util.Success

object CryptoTestValues {
  val testKey = Crypto.decodeKeyBase64("zCNLgkZauiZ072v8ocC6pNZpwtwx/L4Sk9eRPQm2WA8=")
  val pt = "plaintext message"
  val ptBytes = pt.getBytes(StandardCharsets.UTF_8)
  val ctNoAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbBV9Y7blaVRQ4TAcmdJe0Og"
  val ctNoAADBytes = Crypto.base64Decoder.decode(ctNoAAD)
  val ctWithAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbAFhFrzlFNz0cmYHt+TLzkK"
  val ctWithAADBytes = Crypto.base64Decoder.decode(ctWithAAD)

  val invalidKey = Crypto.decodeKeyBase64("nhblIEuU2o4mJunzDRBqhrFncBFcpiJP6Jz6n8RxnMg=")
}

object CryptoScalaCheck {

  implicit val keyGen: Gen[Key] = Gen.resultOf((_: Int) => generateRandomKey())
  implicit val keyArb: Arbitrary[Key] = Arbitrary(keyGen)

  case class BlobLessThan10Mb(bytes: Array[Byte])

  implicit val blobLessThan10MbGen: Gen[BlobLessThan10Mb] = for {
    size <- Gen.choose(0, 10 * 1024 * 1024)
    bytes <- Gen.containerOfN[Array, Byte](size, implicitly[Arbitrary[Byte]].arbitrary)
  } yield BlobLessThan10Mb(bytes)

  implicit val blobLessThan10MbArb: Arbitrary[BlobLessThan10Mb] = Arbitrary(blobLessThan10MbGen)

}

@RunWith(classOf[JUnitRunner])
class CryptoHelperSpec extends Specification with ScalaCheck {

  "Given hand-picked data, crypto functions should" >> {
    import CryptoTestValues._

    "decrypt correctly ciphertexts (generated by another impl)" >> {
      Crypto.decryptField(ctNoAAD, "", testKey) must equalTo(Success(pt))
      Crypto.decryptField(ctNoAAD, "something", testKey).isFailure must beTrue

      Crypto.decryptField(ctWithAAD, "some aad", testKey) must equalTo(Success(pt))
      Crypto.decryptField(ctWithAAD, "other aad", testKey).isFailure must beTrue

      Crypto.decryptField(ctNoAAD, "", invalidKey).isFailure must beTrue
      Crypto.decryptField(ctWithAAD, "some aad", invalidKey).isFailure must beTrue
    }
  }

  "Given arbitrary values, crypto functions should" >> {
    import CryptoScalaCheck._

    "encode and decode correctly keys" >> {
      prop { (key: Key) =>
        val encoded = encodeKeyBase64(key)
        val roundtrip = decodeKeyBase64(encoded)
        key === roundtrip
      }
    }

    "encrypt then decrypt in an idempotent way" >> {
      prop { (pt: String, key: Key, aad: String) =>
        val ct = encryptField(pt, aad, key)
        val roundtrip = ct.flatMap(ct => decryptField(ct, aad, key))
        Success(pt) === roundtrip
      }
    }

  }

  "Given arbitrary values, KeySet should" >> {
    import CryptoScalaCheck._

    "encrypt with the last key" >> {
      prop { (pt: String, key: Key, oldKey: Key, aad: String) =>
        val keyset = KeySet(key, List(oldKey))
        val field = EncryptedField.fromPlainText(pt, aad, keyset).toOption.get
        val decrypted = decryptField(field.cipherTextBase64, aad, key)
        Success(pt) === decrypted
      }
    }

    "decrypt with old key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, Nil)
        val oldEncrypted = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val decrypted = oldEncrypted.decrypt(newKeySet)
        Success(pt) === decrypted
      }
    }

    "decrypt with very old key" >> {
      prop { (pt: String, newKey: Key, oldKey1: Key, oldKey2: Key, oldKey3: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey2, Nil)
        val oldEncrypted = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey1, oldKey2, oldKey3))
        val decrypted = oldEncrypted.decrypt(newKeySet)
        Success(pt) === decrypted
      }
    }
  }

  "Given arbitrary values, EncryptedField should" >> {
    import CryptoScalaCheck._

    "be able to decrypt" >> {
      prop { (pt: String, key: Key, aad: String) =>
        val keySet = KeySet(key, Nil)
        val field = EncryptedField.fromPlainText(pt, aad, keySet).toOption.get
        val decrypted = field.decrypt(keySet)
        Success(pt) === decrypted
      }
    }

    "not decrypt everything" >> {
      prop { (pt: String, key: Key, whateverKey: Key, aad: String) =>
        val validKeySet = KeySet(key, Nil)
        val field = EncryptedField.fromPlainText(pt, aad, validKeySet).toOption.get
        val invalidKeySet = KeySet(whateverKey, Nil)
        val decrypted = field.decrypt(invalidKeySet)
        decrypted.isFailure
      }
    }
  }

  "Given arbitrary values, rekeying should" >> {
    import CryptoScalaCheck._

    "do nothing if new key was used" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val keySet = KeySet(newKey, List(oldKey, oldKey2))
        val field = EncryptedField.fromPlainText(pt, aad, keySet).toOption.get
        val updatedField = field.updateKey(keySet, false)
        Success(None) === updatedField
      }
    }

    "change an old encrypting key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, List(oldKey2))
        val oldField = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val updatedField = oldField.updateKey(newKeySet, false).toOption.get.get
        val newKeyOnlySet = KeySet(newKey, Nil)
        val decrypted = updatedField.decrypt(newKeyOnlySet)
        val decryptedWithOldKeySet = updatedField.decrypt(oldKeySet)
        Success(pt) === decrypted && decryptedWithOldKeySet.isFailure
      }
    }

    "change an old encrypting key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, List(oldKey2))
        val oldField = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val updatedField = oldField.updateKey(newKeySet, false).toOption.get.get
        val newKeyOnlySet = KeySet(newKey, Nil)
        val decrypted = updatedField.decrypt(newKeyOnlySet)
        val decryptedWithOldKeySet = updatedField.decrypt(oldKeySet)
        Success(pt) === decrypted && decryptedWithOldKeySet.isFailure
      }
    }

    "encrypt plaintext if explicit boolean is set" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val field = Crypto.EncryptedField.fromCipherText(pt, aad)
        val keySet1 = KeySet(newKey, Nil)
        val keySet2 = KeySet(newKey, List(oldKey))
        val updatedField1 = field.updateKey(keySet1, true).toOption.get.get
        val updatedField2 = field.updateKey(keySet2, true).toOption.get.get
        val decrypted1 = updatedField1.decrypt(keySet1)
        val decrypted2 = updatedField2.decrypt(keySet1) // here keySet1 should work
        Success(pt) === decrypted1 && Success(pt) === decrypted2
      }
    }

    "not encrypt plaintext without explicit boolean set" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val field = Crypto.EncryptedField.fromCipherText(pt, aad)
        val keySet = KeySet(newKey, List(oldKey))
        val updatedField = field.updateKey(keySet, false)
        updatedField.isFailure
      }
    }

  }

}
