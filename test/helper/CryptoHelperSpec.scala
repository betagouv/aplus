package helper

import helper.Crypto._
import org.junit.runner.RunWith
import org.scalacheck.{Arbitrary, Gen}
import org.specs2.ScalaCheck
import org.specs2.mutable.Specification
import org.specs2.runner.JUnitRunner
import scala.util.Success

@RunWith(classOf[JUnitRunner])
class CryptoHelperSpec extends Specification with ScalaCheck {

  implicit val keyGen: Gen[Key] = Gen.resultOf((_: Int) => generateRandomKey())
  implicit val keyArb = Arbitrary(keyGen)

  "Crypto functions should" >> {

    "decrypt correctly ciphertexts (generated by another impl)" >> {
      val key = Crypto.decodeKeyBase64("zCNLgkZauiZ072v8ocC6pNZpwtwx/L4Sk9eRPQm2WA8=")

      val pt = "plaintext message"

      val ctNoAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbBV9Y7blaVRQ4TAcmdJe0Og"
      Crypto.decryptField(ctNoAAD, "", key) must equalTo(Success(pt))
      Crypto.decryptField(ctNoAAD, "something", key).isFailure must beTrue

      val ctWithAAD = "dW5pcXVlIG5vbmNlSzW1fcYTzwUIbz0hjR14HbAFhFrzlFNz0cmYHt+TLzkK"
      Crypto.decryptField(ctWithAAD, "some aad", key) must equalTo(Success(pt))
      Crypto.decryptField(ctWithAAD, "other aad", key).isFailure must beTrue

      val invalidKey = Crypto.decodeKeyBase64("nhblIEuU2o4mJunzDRBqhrFncBFcpiJP6Jz6n8RxnMg=")
      Crypto.decryptField(ctNoAAD, "", invalidKey).isFailure must beTrue
      Crypto.decryptField(ctWithAAD, "some aad", invalidKey).isFailure must beTrue
    }

    "encode and decode correctly keys" >> {
      prop { (key: Key) =>
        val encoded = encodeKeyBase64(key)
        val roundtrip = decodeKeyBase64(encoded)
        key === roundtrip
      }
    }

    "encrypt then decrypt should be idempotent" >> {
      prop { (pt: String, key: Key, aad: String) =>
        val ct = encryptField(pt, aad, key)
        val roundtrip = ct.flatMap(ct => decryptField(ct, aad, key))
        Success(pt) === roundtrip
      }
    }

    "KeySet should encrypt with the last key" >> {
      prop { (pt: String, key: Key, oldKey: Key, aad: String) =>
        val keyset = KeySet(key, List(oldKey))
        val field = EncryptedField.fromPlainText(pt, aad, keyset).toOption.get
        val decrypted = decryptField(field.cipherTextBase64, aad, key)
        Success(pt) === decrypted
      }
    }

    "KeySet should decrypt with old key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, Nil)
        val oldEncrypted = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val decrypted = oldEncrypted.decrypt(newKeySet)
        Success(pt) === decrypted
      }
    }

    "KeySet should decrypt with very old key" >> {
      prop { (pt: String, newKey: Key, oldKey1: Key, oldKey2: Key, oldKey3: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey2, Nil)
        val oldEncrypted = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey1, oldKey2, oldKey3))
        val decrypted = oldEncrypted.decrypt(newKeySet)
        Success(pt) === decrypted
      }
    }

    "EncryptedField should be able to decrypt" >> {
      prop { (pt: String, key: Key, aad: String) =>
        val keySet = KeySet(key, Nil)
        val field = EncryptedField.fromPlainText(pt, aad, keySet).toOption.get
        val decrypted = field.decrypt(keySet)
        Success(pt) === decrypted
      }
    }

    "EncryptedField should not decrypt everything" >> {
      prop { (pt: String, key: Key, whateverKey: Key, aad: String) =>
        val validKeySet = KeySet(key, Nil)
        val field = EncryptedField.fromPlainText(pt, aad, validKeySet).toOption.get
        val invalidKeySet = KeySet(whateverKey, Nil)
        val decrypted = field.decrypt(invalidKeySet)
        decrypted.isFailure
      }
    }

    "Rekeying should do nothing if new key was used" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val keySet = KeySet(newKey, List(oldKey, oldKey2))
        val field = EncryptedField.fromPlainText(pt, aad, keySet).toOption.get
        val updatedField = field.updateKey(keySet, false)
        Success(None) === updatedField
      }
    }

    "Rekeying should change an old encrypting key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, List(oldKey2))
        val oldField = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val updatedField = oldField.updateKey(newKeySet, false).toOption.get.get
        val newKeyOnlySet = KeySet(newKey, Nil)
        val decrypted = updatedField.decrypt(newKeyOnlySet)
        val decryptedWithOldKeySet = updatedField.decrypt(oldKeySet)
        Success(pt) === decrypted && decryptedWithOldKeySet.isFailure
      }
    }

    "Rekeying should change an old encrypting key" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, oldKey2: Key, aad: String) =>
        val oldKeySet = KeySet(oldKey, List(oldKey2))
        val oldField = EncryptedField.fromPlainText(pt, aad, oldKeySet).toOption.get
        val newKeySet = KeySet(newKey, List(oldKey))
        val updatedField = oldField.updateKey(newKeySet, false).toOption.get.get
        val newKeyOnlySet = KeySet(newKey, Nil)
        val decrypted = updatedField.decrypt(newKeyOnlySet)
        val decryptedWithOldKeySet = updatedField.decrypt(oldKeySet)
        Success(pt) === decrypted && decryptedWithOldKeySet.isFailure
      }
    }

    "Rekeying should encrypt plaintext if explicit boolean is set" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val field = Crypto.EncryptedField.fromCipherText(pt, aad)
        val keySet1 = KeySet(newKey, Nil)
        val keySet2 = KeySet(newKey, List(oldKey))
        val updatedField1 = field.updateKey(keySet1, true).toOption.get.get
        val updatedField2 = field.updateKey(keySet2, true).toOption.get.get
        val decrypted1 = updatedField1.decrypt(keySet1)
        val decrypted2 = updatedField2.decrypt(keySet1) // here keySet1 should work
        Success(pt) === decrypted1 && Success(pt) === decrypted2
      }
    }

    "Rekeying should not encrypt plaintext without explicit boolean set" >> {
      prop { (pt: String, newKey: Key, oldKey: Key, aad: String) =>
        val field = Crypto.EncryptedField.fromCipherText(pt, aad)
        val keySet = KeySet(newKey, List(oldKey))
        val updatedField = field.updateKey(keySet, false)
        updatedField.isFailure
      }
    }

  }

}
